//  main.cpp (C++ version)
//  sebestaScannerCpp

//#include <string>
//#include <cstdio>
//#include <cctype>
#include <iostream>  // I/O
#include <fstream>   // file I/O
#include <iomanip>   // format manipulation
#include <unistd.h>  // unix standard header
//#include <std_lib_facilities.h>

using namespace std;

int charClass;
string lexeme; // In contrast to C, C++ has a true string data type
char nextChar;
int token;
int nextToken;
bool decFlag;
ifstream in_fp; // input file stream object which has some methods

void my_getChar();

int lex();

// C++ has true constants, whereas C simulates
// comments via preprocessor define directives
const int LETTER = 0;
const int DIGIT = 1;
const int DEC_POINT = 2;
const int COLON_CHAR = 3;
const int EQUAL_CHAR = 4;
const int UNKNOWN = 99;

const int FLOAT_LIT = 10;
const int VARNAME = 11;
const int ADD_OP = 21;
const int SUB_OP = 22;
const int MULT_OP = 23;
const int DIV_OP = 24;
const int LEFT_PAREN = 25;
const int RIGHT_PAREN = 26;
const int IF_KEY = 27;
const int ELSE_KEY = 28;
const int ASSIGN_OP = 29;

int main(int argc, const char *argv[]) // Same as C
{
    //    in_fp.open("/Users/maida/Documents/teaching/cmps450G/scannerTokenizer/scanners_3langs_sebesta_chapt3/sebestaScannerCpp/front.in");
    in_fp.open("test_data.in.txt");
    if (in_fp.is_open()) {
        //        cout << "front.in opened" << endl;
        my_getChar();
        do {
            lex();
        } while (nextToken != EOF);
    } else {
        cout << "Cannot open test_data.in" << endl;
        char cwd[1024]; // Another string buffer w/ capacity = 1023 chars
        if (getcwd(cwd, sizeof(cwd)) != NULL) {
            cout << "Current working dir: " << cwd << endl;
        } // C++ I/O is stream based and harder to understand
    }
    return 0;
}

void my_addChar() {
    // much improved in C++
    lexeme += nextChar; // string concatenation
}

void my_getChar() {
    in_fp.get(nextChar); // read the next character
    if (in_fp.eof())
        charClass = EOF;
    else {
        if (isalpha(nextChar))
            charClass = VARNAME;
        else if (isdigit(nextChar)) {
            if (charClass == VARNAME) {
                charClass = VARNAME;
            }
            charClass = FLOAT_LIT;
        } else if (nextChar == ':')
            charClass = ASSIGN_OP;
        else if (nextChar == '=' && charClass == ASSIGN_OP) {
            charClass = ASSIGN_OP;
        } else if (nextChar == '.' && !decFlag) {
            charClass = FLOAT_LIT;
            decFlag = true;
        } else charClass = UNKNOWN;
    }

    //    cout << nextChar<<endl;  // for debugging
}

void getNonBlank() {
    while (isspace(nextChar))
        my_getChar();
}

int lookup(char ch) {
    // Same as C version
    switch (ch) {
        case '(':
            my_addChar();
            nextToken = LEFT_PAREN;
            break;
        case ')':
            my_addChar();
            nextToken = RIGHT_PAREN;
            break;
        case '+':
            my_addChar();
            nextToken = ADD_OP;
            break;
        case '-':
            my_addChar();
            nextToken = SUB_OP;
            break;
        case '*':
            my_addChar();
            nextToken = MULT_OP;
            break;
        case '/':
            my_addChar();
            nextToken = DIV_OP;
            break;
        default:
            my_addChar();
            nextToken = UNKNOWN;
            break;
    }
    return nextToken;
}

int lex() {
    lexeme = ""; // not a declaration. "lexeme" is global.
    getNonBlank();
    switch (charClass) {
        case VARNAME:
            my_addChar();
            my_getChar();
            while (charClass == VARNAME || charClass == FLOAT_LIT) {
                my_addChar();
                my_getChar();
            }
            nextToken = VARNAME;
            break;
        case FLOAT_LIT:
            my_addChar();
            my_getChar();
            while (charClass == FLOAT_LIT) {
                my_addChar();
                my_getChar();
            }
            nextToken = FLOAT_LIT;
            break;
        case UNKNOWN:
            lookup(nextChar);
            my_getChar();
            nextToken = UNKNOWN;
            break;
        case ASSIGN_OP:
            my_addChar();
            my_getChar();
            while (charClass == ASSIGN_OP) {
                my_addChar();
                my_getChar();
            }
            nextToken = ASSIGN_OP;
            break;
        case DIV_OP || ADD_OP || SUB_OP || MULT_OP:
            my_addChar();
            nextToken = lookup(nextChar);
            break;
        case EOF:
            nextToken = EOF;
            lexeme = "EOF";
            break;
    }
    if (lexeme.compare("if") == 0) {
        nextToken = IF_KEY;
    }
    if (lexeme.compare("else") == 0) {
        nextToken = ELSE_KEY;
    }
    cout << "Next token is: " << nextToken << ", Next lexeme is: " << lexeme << endl;
    decFlag = false;
    return nextToken;
}
